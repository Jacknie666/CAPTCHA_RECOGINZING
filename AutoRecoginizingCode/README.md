
## 环境要求

- Python 3.7+
- OpenCV
- NumPy
- TensorFlow (Keras)

## 安装依赖

建议在虚拟环境中安装依赖，以避免与系统库冲突。

1.  **创建并激活虚拟环境 (可选但推荐，若不会虚拟环境，也可直接运行)**:
    ```bash
    python3 -m venv venv
    source venv/bin/activate  # macOS/Linux
    # venv\Scripts\activate   # Windows
    ```

2.  **安装所需库**:
    ```bash
    pip install opencv-python numpy tensorflow
    ```
    或者，如果有一个 `requirements.txt` 文件:
    ```
    opencv-python
    numpy
    tensorflow
    ```
    然后运行: `pip install -r requirements.txt`

## 使用方法

1.  **准备图片**:
    *   将你想要识别的验证码图片（例如 `test1.png`, `my_captcha.jpg` 等）放入 `custom_images` 文件夹中。
    *   确保图片中的数字是手写风格，并且背景相对简单，字符之间有一定区隔。

2.  **修改脚本中的图片路径**:
    打开 `ModelIdentify.py` 文件，找到以下这行代码：
    ```python
    captcha_file_path = 'custom_images/test1.png'
    ```
    将其中的 `'custom_images/test1.png'` 修改为你实际想要识别的图片文件的路径。例如，如果你想识别 `custom_images/my_image.png`，则修改为：
    ```python
    captcha_file_path = 'custom_images/my_image.png'
    ```

3.  **运行脚本**:
    在项目根目录（即 `手写体` 文件夹）下打开终端或命令行，运行：
    ```bash
    python Model_Identify.py
    ```

4.  **查看结果**:
    *   脚本运行时，会首先弹出一个名为 "Thresholded CAPTCHA" 的窗口，显示经过二值化处理的图片。你需要**在此窗口激活的状态下按任意键**，程序才会继续执行。
    *   之后，如果找到字符，会弹出 "Segmented Characters" 窗口，显示在原始图片上圈出的被识别字符以及模型对每个字符的预测。同样，你需要**在此窗口激活的状态下按任意键**来关闭窗口并结束程序。
    *   最终识别出的验证码文本会在终端打印出来。同时，每个分割字符的预测详情也会打印在终端。

## 工作流程简述

1.  **加载模型**: 加载预训练的 `mnist_cnn_best_model.h5`。
2.  **读取图片**: 使用 OpenCV 读取指定的验证码图片。
3.  **图像预处理**:
    *   转换为灰度图。
    *   使用 Otsu 方法进行二值化，使字符变为白色，背景变为黑色。
4.  **字符分割**:
    *   使用 `cv2.findContours` 寻找图像中的所有外部轮廓。
    *   通过面积阈值过滤掉过小或过大的轮廓，保留可能是字符的轮廓。
    *   将找到的字符轮廓按其 x 坐标从左到右排序。
5.  **单个字符预测**:
    *   对每个分割出的字符区域 (ROI)：
        *   提取该区域。
        *   添加黑色边框（padding）使其接近正方形，以保持字符在缩放时的宽高比。
        *   缩放到 28x28 像素（MNIST 模型输入尺寸）。
        *   归一化像素值到 0-1 范围。
        *   调整形状以匹配模型输入要求 `(1, 28, 28, 1)`。
        *   使用加载的 MNIST 模型进行预测。
        *   获取概率最高的数字作为预测结果。
6.  **结果组合**: 将所有单个字符的预测结果按顺序拼接成最终的验证码字符串。
7.  **显示与输出**: 显示中间处理图像、最终分割图像和预测结果，并在控制台打印识别文本。

## 注意事项与限制

*   **模型能力**:
    *   此模型基于 MNIST 数据集训练，因此**只能识别数字 0-9**。它无法识别字母或其他符号。
    *   对于非 MNIST 风格的字体、严重的扭曲、旋转或噪声，识别效果可能会下降。
*   **字符分割**:
    *   当前的分割方法基于简单的轮廓检测和面积过滤。对于字符粘连、重叠、断裂，或者背景中有复杂干扰线/点的情况，分割效果可能不佳，从而导致识别错误。
    *   轮廓排序仅按 x 坐标，适用于单行验证码。对于多行验证码，字符的读取顺序可能不正确（例如，可能会将第一行和第二行的字符混合排序）。
    *   `cv2.contourArea(contour) > 50` 这个面积阈值可能需要根据你实际验证码中字符的大小进行调整。
*   **图像预处理**:
    *   `cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU` 假设字符比背景暗（在原始灰度图中），通过反转二值化后字符变白。如果你的验证码字符本身比背景亮，可能需要调整阈值化方法。
*   **输入图片**:
    *   图片应放置在 `custom_images` 文件夹下，并在脚本中正确指定路径。
    *   支持 OpenCV `imread` 函数能够读取的常见图片格式 (如 PNG, JPG, BMP)。
*   **调试窗口**: 程序会通过 `cv2.imshow` 显示图片。你需要激活这些窗口并按键才能使程序继续或结束。

## 关于模型训练

此 README 主要关注 `ModelIndentify.py` 的使用。项目中的 `Modertraining.py` 文件仅用于训练 `mnist_cnn_best_model.h5` 模型的脚本。如果你想了解模型是如何训练的，或者想重新训练模型，请查看该脚本的内容。

---